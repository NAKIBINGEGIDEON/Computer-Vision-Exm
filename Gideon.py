# -*- coding: utf-8 -*-
"""Copy of Finalwork.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E_ObAZf0la81SYQe6T2v9TH05jMcUK63
"""

import tensorflow as tf
from keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import confusion_matrix, classification_report, roc_auc_score, roc_curve, auc
import matplotlib.pyplot as plt
import numpy as np



# Function to build ResNet model
def build_resnet():
    resnet = tf.keras.applications.ResNet50(include_top=False, weights='imagenet', input_shape=(224, 224, 3))
    x = resnet.output
    x = tf.keras.layers.GlobalAveragePooling2D()(x)
    x = tf.keras.layers.Dense(1024, activation='relu')(x)
    x = tf.keras.layers.Dropout(0.5)(x)
    predictions = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    resnet_model = tf.keras.models.Model(inputs=resnet.input, outputs=predictions)
    resnet_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return resnet_model

# Function to build MobileNet model
def build_mobilenet():
    mobilenet = tf.keras.applications.MobileNetV2(include_top=False, weights='imagenet', input_shape=(224, 224, 3))
    x = mobilenet.output
    x = tf.keras.layers.GlobalAveragePooling2D()(x)
    x = tf.keras.layers.Dense(1024, activation='relu')(x)
    x = tf.keras.layers.Dropout(0.5)(x)
    predictions = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    mobilenet_model = tf.keras.models.Model(inputs=mobilenet.input, outputs=predictions)
    mobilenet_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return mobilenet_model

# Function to build GoogleNet (Inception) model
def build_googlenet():
    inception = tf.keras.applications.InceptionV3(include_top=False, weights='imagenet', input_shape=(224, 224, 3))
    x = inception.output
    x = tf.keras.layers.GlobalAveragePooling2D()(x)
    x = tf.keras.layers.Dense(1024, activation='relu')(x)
    x = tf.keras.layers.Dropout(0.5)(x)
    predictions = tf.keras.layers.Dense(1, activation='sigmoid')(x)
    googlenet_model = tf.keras.models.Model(inputs=inception.input, outputs=predictions)
    googlenet_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return googlenet_model

# Train and evaluate models
def train_and_evaluate(model, model_name):
    print(f"Training {model_name}...")
    model.fit(x=training_set, validation_data=test_set, epochs=2)  # Reduced to 2 epochs

    print(f"Evaluating {model_name}...")
    test_set.reset()
    predictions = model.predict(test_set)
    predicted_classes = (predictions > 0.5).astype(int).reshape(-1)
    true_classes = test_set.classes

    cm = confusion_matrix(true_classes, predicted_classes)
    print(f"Confusion Matrix for {model_name}")
    print(cm)

    report = classification_report(true_classes, predicted_classes, target_names=['saloon_car', 'motorcycle'])
    print(f"Classification Report for {model_name}")
    print(report)

    fpr, tpr, thresholds = roc_curve(true_classes, predictions)
    roc_auc = auc(fpr, tpr)
    print(f"AUC for {model_name}: ", roc_auc)

    return fpr, tpr, roc_auc

# Build models
resnet = build_resnet()
mobilenet = build_mobilenet()
googlenet = build_googlenet()

# Train and evaluate models
fpr_resnet, tpr_resnet, roc_auc_resnet = train_and_evaluate(resnet, "ResNet")
fpr_mobilenet, tpr_mobilenet, roc_auc_mobilenet = train_and_evaluate(mobilenet, "MobileNet")
fpr_googlenet, tpr_googlenet, roc_auc_googlenet = train_and_evaluate(googlenet, "GoogleNet")

# Plot ROC curves
plt.figure()
plt.plot(fpr_resnet, tpr_resnet, color='blue', lw=2, label='ResNet ROC curve (area = %0.2f)' % roc_auc_resnet)
plt.plot(fpr_mobilenet, tpr_mobilenet, color='green', lw=2, label='MobileNet ROC curve (area = %0.2f)' % roc_auc_mobilenet)
plt.plot(fpr_googlenet, tpr_googlenet, color='red', lw=2, label='GoogleNet ROC curve (area = %0.2f)' % roc_auc_googlenet)
plt.plot([0, 1], [0, 1], color='black', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()